<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="example example-like"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">1.28</span><span class="period">.</span>
</h4>
<div class="para logical"><ol class="decimal">
<li><div class="para">Many categories one may think about are concrete categories, where the objects are sets with some extra structure, and the arrows are functions between those sets that preserved that extra structure. The <em class="emphasis">forgetful functor</em> from such a category to <span class="process-math">\(\Set\)</span> is the functor that, just as the name says, forgets that extra structure, and sees only the underlying sets and functions of sets. For example, the forgetful functor <span class="process-math">\(\mathbf{G r} \longrightarrow\)</span> <span class="process-math">\(\Set\)</span> sends each group to its underlying set, and each group homomorphism to the corresponding function of sets.</div></li>
<li><div class="para">The <em class="emphasis">identity functor</em> <span class="process-math">\(1_{\mathscr{C}}\)</span> on any category <span class="process-math">\(\mathscr{C}\)</span> does what the name suggests: it sends each object to itself and each arrow to itself.</div></li>
<li><div class="para logical">
<div class="para">Given a group <span class="process-math">\(G\text{,}\)</span> the subgroup <span class="process-math">\([G, G]\)</span> of <span class="process-math">\(G\)</span> generated by the set of commutators</div>
<div class="displaymath process-math">
\begin{equation*}
\left\{g h g^{-1} h^{-1} \mid g, h \in G\right\}
\end{equation*}
</div>
<div class="para">is a normal subgroup, and the quotient <span class="process-math">\(G^{\text {ab }}:=G /[G, G]\)</span> is called the abelianization of <span class="process-math">\(G\text{.}\)</span> The group <span class="process-math">\(G^{\text {ab }}\)</span> is abelian. Given a group homomorphism <span class="process-math">\(f: G \rightarrow H, f\)</span> automatically takes commutators to commutators, so it induces a homomorphism <span class="process-math">\(\tilde{f}: G^{\mathrm{ab}} \rightarrow H^{\mathrm{ab}}\text{.}\)</span> More precisely, abelianization gives a covariant functor from <span class="process-math">\(\Grp\)</span> to <span class="process-math">\(\Ab\text{.}\)</span>
</div>
</div></li>
<li><div class="para logical">
<div class="para">The <em class="emphasis">unit group functor</em> <span class="process-math">\(-^{*}\)</span> : <span class="process-math">\(\Ring\)</span> <span class="process-math">\(\rightarrow\)</span> <span class="process-math">\(\Grp\)</span> sends a ring <span class="process-math">\(R\)</span> to its group of units <span class="process-math">\(R^{*}\text{.}\)</span> To see this is indeed a functor, we should check it behaves well on morphisms; and indeed if <span class="process-math">\(f: R \rightarrow S\)</span> is a ring homomorphism, and <span class="process-math">\(u \in R^{*}\)</span> is a unit in <span class="process-math">\(R\text{,}\)</span> then</div>
<div class="displaymath process-math">
\begin{equation*}
f(u) f\left(u^{-1}\right)=f\left(u u^{-1}\right)=f\left(1_{R}\right)=1_{S},
\end{equation*}
</div>
<div class="para">so <span class="process-math">\(f(u)\)</span> is a unit in <span class="process-math">\(S\text{.}\)</span> Thus <span class="process-math">\(f\)</span> induces a function <span class="process-math">\(R^{*} \rightarrow S^{*}\)</span> given by restriction of <span class="process-math">\(f\)</span> to <span class="process-math">\(R^{*}\text{,}\)</span> which must therefore be a group homomorphism since <span class="process-math">\(f\)</span> preserves products.</div>
</div></li>
<li><div class="para">Fix a field <span class="process-math">\(k\text{.}\)</span> Given a vector space <span class="process-math">\(V\text{,}\)</span> the collection <span class="process-math">\(V^{*}\)</span> of linear transformations from <span class="process-math">\(V\)</span> to <span class="process-math">\(k\)</span> is again a <span class="process-math">\(k\)</span>-vector space, the <em class="emphasis">dual vector space</em> of <span class="process-math">\(V\text{.}\)</span> If <span class="process-math">\(\varphi: W \rightarrow V\)</span> is a linear transformation and <span class="process-math">\(\ell: V \rightarrow K\)</span> is an element of <span class="process-math">\(V^{*}\text{,}\)</span> then <span class="process-math">\(\ell \circ \varphi: W \rightarrow k\)</span> is in <span class="process-math">\(W^{*}\text{.}\)</span> Doing this for all elements <span class="process-math">\(\ell \in V^{*}\)</span> gives a function <span class="process-math">\(\varphi^{*}: V^{*} \rightarrow W^{*}\text{,}\)</span> and one can show that <span class="process-math">\(\varphi^{*}\)</span> is a linear transformation. The assignment that sends each vector space <span class="process-math">\(V\)</span> to its dual vector space <span class="process-math">\(V^{*}\)</span> and each linear transformation <span class="process-math">\(\varphi\)</span> to <span class="process-math">\(\varphi^{*}\)</span> is a contravariant functor on Vect- <span class="process-math">\(k\text{.}\)</span>
</div></li>
<li><div class="para">Localization is a functor. Let <span class="process-math">\(R\)</span> be a ring and <span class="process-math">\(W\)</span> be a multiplicatively closed set in <span class="process-math">\(R\text{.}\)</span> There is localization at <span class="process-math">\(W\)</span> induces a a functor <span class="process-math">\(R\)</span><span class="process-math">\(\mod\)</span> <span class="process-math">\(\longrightarrow W^{-1} R\)</span><span class="process-math">\(\mod\)</span> that sends each <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\)</span> to <span class="process-math">\(W^{-1} M\text{,}\)</span> and each <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(\alpha: M \longrightarrow N\)</span> to the <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(W^{-1} \alpha: W^{-1} M \longrightarrow W^{-1} N\text{.}\)</span>
</div></li>
</ol></div></article><span class="incontext"><a href="sec-functors.html#example-19" class="internal">in-context</a></span>
</body>
</html>
