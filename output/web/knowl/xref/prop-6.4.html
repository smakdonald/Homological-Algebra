<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="proposition theorem-like"><h4 class="heading">
<span class="type">Proposition</span><span class="space"> </span><span class="codenumber">6.4</span><span class="period">.</span><span class="space"> </span><span class="title">.</span>
</h4>
<div class="para logical">
<div class="para">Let <span class="process-math">\(F: R \operatorname{Mod} \rightarrow S\Mod\)</span> be a covariant right exact functor.</div>
<ol class="decimal">
<li><div class="para">
<span class="process-math">\(L_{i} F(A)\)</span> is well-de ned up to isomorphism for every object <span class="process-math">\(A\text{.}\)</span>
</div></li>
<li><div class="para">
<span class="process-math">\(L_{i} F(f)\)</span> is well-de ned for every arrow <span class="process-math">\(f\text{.}\)</span>
</div></li>
<li><div class="para">
<span class="process-math">\(L_{i} F\)</span> is an additive functor for each <span class="process-math">\(i\text{.}\)</span>
</div></li>
<li><div class="para"><span class="process-math">\(L_{0} F=F\text{.}\)</span></div></li>
</ol>
</div></article><details class="hiddenproof born-hidden-knowl"><summary><h4 class="heading"><span class="type">Proof<span class="period">.</span></span></h4></summary><article class="hiddenproof"><div class="para logical"><ol class="decimal">
<li><div class="para">Let <span class="process-math">\(P\)</span> and <span class="process-math">\(Q\)</span> be projective resolutions of <span class="process-math">\(A\text{.}\)</span> <a href="sec-proj-res.html#thm-5.17" class="xref" data-knowl="./knowl/xref/thm-5.17.html" data-reveal-label="Reveal" data-close-label="Close" title="Theorem 5.21">Theorem 5.21</a> gives us maps of complexes <span class="process-math">\(\varphi: P \rightarrow Q\)</span> and <span class="process-math">\(\psi: Q \rightarrow P\)</span> such that <span class="process-math">\(\varphi \psi\)</span> is homotopic to <span class="process-math">\(1_{Q}\)</span> and <span class="process-math">\(\psi \varphi\)</span> is homotopic to <span class="process-math">\(1_{P}\text{.}\)</span> Additive functors preserve homotopies, by Remark 7.35, so <span class="process-math">\(F(\varphi) F(\psi)\)</span> and <span class="process-math">\(F(\psi) F(\varphi)\)</span> are homotopic to the corresponding identity maps. Homotopic maps induce the same map in homology, by <a href="sec-compelx-maps.html#lem-2.9" class="xref" data-knowl="./knowl/xref/lem-2.9.html" data-reveal-label="Reveal" data-close-label="Close" title="Lemma 2.19: Nullhomotopic Maps Induce Zero Map in Homology">Lemma 2.19</a>. Therefore, <span class="process-math">\(F(\varphi)\)</span> and <span class="process-math">\(F(\psi)\)</span> induce isomorphisms in homology.</div></li>
<li><div class="para">Fix projective resolutions <span class="process-math">\(P\)</span> and <span class="process-math">\(Q\)</span> of <span class="process-math">\(M\)</span> and <span class="process-math">\(N\text{.}\)</span> Any two lifts <span class="process-math">\(\varphi\)</span> and <span class="process-math">\(\psi\)</span> of <span class="process-math">\(f: M \rightarrow N\)</span> to <span class="process-math">\(P \rightarrow Q\)</span> are homotopic, by <a href="sec-proj-res.html#thm-5.17" class="xref" data-knowl="./knowl/xref/thm-5.17.html" data-reveal-label="Reveal" data-close-label="Close" title="Theorem 5.21">Theorem 5.21</a>. Additive functors preserve homotopies, by Remark 7.35, so <span class="process-math">\(F(\varphi)\)</span> and <span class="process-math">\(F(\psi)\)</span> are homotopic. Homotopic maps induce the same map in homology, by <a href="sec-compelx-maps.html#lem-2.9" class="xref" data-knowl="./knowl/xref/lem-2.9.html" data-reveal-label="Reveal" data-close-label="Close" title="Lemma 2.19: Nullhomotopic Maps Induce Zero Map in Homology">Lemma 2.19</a>, so <span class="process-math">\(L_{i} F(\varphi)=L_{i} F(\psi)\)</span> for each <span class="process-math">\(i\text{.}\)</span>
</div></li>
<li><div class="para">Given an arrow <span class="process-math">\(f\text{,}\)</span> fix a lift <span class="process-math">\(\varphi\)</span> of <span class="process-math">\(f\)</span> to projective resolutions of the source and target, which exists by <a href="sec-proj-res.html#thm-5.17" class="xref" data-knowl="./knowl/xref/thm-5.17.html" data-reveal-label="Reveal" data-close-label="Close" title="Theorem 5.21">Theorem 5.21</a>. Since <span class="process-math">\(F\)</span> is an additive functor, <span class="process-math">\(\mathrm{H}_{i}(F(\varphi))\)</span> is a homomorphism for each <span class="process-math">\(i\text{,}\)</span> and thus <span class="process-math">\(L_{i} F(f)\)</span> is a homomorphism between the corresponding Hom-groups, which as we have seen is independent of our choice of <span class="process-math">\(\varphi\text{.}\)</span>
</div></li>
<li>
<div class="para logical">
<div class="para">Let <span class="process-math">\(A\)</span> be any <span class="process-math">\(R\)</span>-module and <span class="process-math">\(P\)</span> be a projective resolution of <span class="process-math">\(A\text{.}\)</span> Since <span class="process-math">\(P\)</span> is right exact, and</div>
<div class="displaymath process-math">
\begin{equation*}
P_{1} \longrightarrow P_{0} \longrightarrow A \longrightarrow 0
\end{equation*}
</div>
<div class="para">is exact, then so is</div>
<div class="displaymath process-math">
\begin{equation*}
F\left(P_{1}\right) \longrightarrow F\left(P_{0}\right) \longrightarrow F(A) \longrightarrow 0
\end{equation*}
</div>
</div>
<div class="para logical">
<div class="para">We claim that <span class="process-math">\(\mathrm{H}_{0}(F(P))=F(A)\text{.}\)</span> The last sequence above says that</div>
<div class="displaymath process-math">
\begin{equation*}
F(A)=\operatorname{coker}\left(F\left(P_{1}\right) \rightarrow F\left(P_{0}\right)\right),
\end{equation*}
</div>
<div class="para">and <span class="process-math">\(\mathrm{H}_{0}(F(P))=F\left(P_{0}\right) / \operatorname{im}\left(F\left(P_{1}\right) \rightarrow F\left(P_{0}\right)\right)=\operatorname{coker}\left(F\left(P_{1}\right) \rightarrow F\left(P_{0}\right)\right)\text{.}\)</span>
</div>
</div>
</li>
</ol></div></article></details><span class="incontext"><a class="internal" href="sec-construction.html#prop-6.4">in-context</a></span>
</body>
</html>
